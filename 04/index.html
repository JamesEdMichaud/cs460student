<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Vanilla WebGL!</title>
  <style>
    html, body {
      background-color:#000;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden !important;
      background-image: url(https://cs460.org/gfx/bg.gif);
      background-repeat: no-repeat;
      background-size: 100% 100%;
    }

    #c {
      width: 100%;
      height: 100%;
    }

    #scoreboard {
      position: absolute;
      top: 10px;
      right: 10px;
    }
  </style>
</head>
<script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>

<script id="vertexshader" type="glsl">
    attribute vec3 a_position;
    uniform vec3 u_offset;

    void main(void) {
      gl_PointSize = 10.0;
      vec3 final_position = a_position;
      final_position.x += u_offset.x;
      final_position.y += u_offset.y;
      final_position.z += u_offset.z;
      gl_Position = vec4( final_position, 1.0);
    }
  </script>

<script id="fragmentshader" type="glsl">
    precision mediump float;
    uniform vec4 u_color;
    void main(void) {
      gl_FragColor = u_color;
    }
  </script>

<script>

  let c, gl;
  let v_shader, f_shader, shaderprogram;
  let vertices, indices, v_buffer, i_buffer;

  let step_x = 0.01;
  let step_y = 0.01;
  let obstacle_factor = 3; // Hint for the bonus!
  let direction_y = 0;
  let direction_x = 0;
  let airplane;


  window.onload = function() {
    //************************************************************//
    // INITIALIZE WEBGL
    //************************************************************//
    c = document.getElementById( 'c' ); // setup canvas
    c.width = window.innerWidth;
    c.height = window.innerHeight;

    gl = c.getContext( 'webgl' ); // setup GL context
    gl.viewport(0, 0, c.width, c.height );

    //************************************************************//
    // SHADERS
    //************************************************************//
    v_shader = gl.createShader( gl.VERTEX_SHADER );
    f_shader = gl.createShader( gl.FRAGMENT_SHADER );

    // compile vertex shader
    gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
    gl.compileShader( v_shader );
    if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog( v_shader )); }

    // compile fragment shader
    gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
    gl.compileShader( f_shader );
    if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog( f_shader )); }

    // attach and link the shaders
    shaderprogram = gl.createProgram();
    gl.attachShader( shaderprogram, v_shader );
    gl.attachShader( shaderprogram, f_shader );

    gl.linkProgram( shaderprogram );
    gl.useProgram( shaderprogram );


    // create multiple objects
    airplane = createAirplane();
    objects = [];
    objects.push( airplane );
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());
    objects.push( createObstacle());

    animate();
  };

  function createAirplane() {
    //
    // Part 1 Starts
    //
    let vertices = new Float32Array( [
      -3.0,  2.0, 0.0,
      -3.0, -2.0, 0.0,
      -1.0,  1.0, 0.0,
       1.0,  1.0, 0.0,
       1.0,  0.0, 0.0,
       3.0,  0.0, 0.0
    ] );
    for (let i = 0; i < vertices.length; i++) vertices[i] /= 64;

    let indices = new Uint8Array( [
            0, 1, 2,
            1, 2, 4,
            2, 3, 4,
            3, 4, 5
    ]);

    let v_buffer = gl.createBuffer(); // create
    gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
    gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

    let i_buffer = gl.createBuffer(); // create
    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); //bind
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind




    //
    // Part 1 Ends
    //

    let offset = [0.0, 0.0, 0.0];
    let color = [1.0, 1.0, 1.0, 1.0];

    //
    // Bonus Part 3!
    //
    return ['airplane', v_buffer, i_buffer, vertices, offset, color, gl.TRIANGLES, indices];
  }

  function createObstacle() {
    let vertices = new Float32Array( [ 0.0, 0.0, 0.0 ]);

    let v_buffer = gl.createBuffer(); // create
    gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
    gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

    //
    // Part 2 Starts
    //
    let offset = [2*Math.random()-1, 2*Math.random()-1, 0.0];

    // let indices = new Uint8Array( [ 0, 0, 0 ]);
    //
    // let i_buffer = gl.createBuffer(); // create
    // gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); //bind
    // gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
    // gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind

    //
    // Part 2 Ends
    //

    let color = [Math.random(),Math.random(),Math.random(),1.0];

    return ['obstacle', v_buffer, null, vertices, offset, color, gl.POINTS, null];
  }



  //
  // Part 3 Starts (no coding required, just explanations in PDF)
  //
  function calculateBoundingBox(vertices, offset) {
    let minx = 1000;
    let maxx = -1000;
    let miny = 1000;
    let maxy = -1000;
    let minz = 1000;
    let maxz = -1000;

    for (let v=0; v<vertices.length; v+=3) {
      let currentx = vertices[v] + offset[0];
      let currenty = vertices[v+1] + offset[1];
      let currentz = vertices[v+2] + offset[2];

      minx = Math.min( minx, currentx );
      miny = Math.min( miny, currenty );
      minz = Math.min( minz, currentz );

      maxx = Math.max( maxx, currentx );
      maxy = Math.max( maxy, currenty );
      maxz = Math.max( maxz, currentz );
    }
    return [minx, maxx, miny, maxy, minz, maxz];
  }

  function detectCollision(bbox, point) {
    let collision = false;

    if (point[0] >= bbox[0] && point[0] <= bbox[1]) {
      if (point[1] >= bbox[2] && point[1] <= bbox[3]) {
        if (point[2] >= bbox[4] && point[2] <= bbox[5]) {
          collision = true;
        }
      }
    }
    return collision;
  }
  //
  // Part 3 Ends
  //



  //
  // Part 4 Starts
  //
  window.onkeydown = function(e) {
    if      (e.code === "ArrowUp"    ) direction_y =  1;
    else if (e.code === "ArrowDown"  ) direction_y = -1;
    else if (e.code === "ArrowLeft"  ) direction_x = -1;
    else if (e.code === "ArrowRight" ) direction_x =  1;
  };

  window.onkeyup = function(e) {
    if      (e.code === "ArrowUp"    ) direction_y = 0;
    else if (e.code === "ArrowDown"  ) direction_y = 0;
    else if (e.code === "ArrowLeft"  ) direction_x = 0;
    else if (e.code === "ArrowRight" ) direction_x = 0;
  };

  //
  // Part 4 Ends
  //

  let framecounter = 0;
  let obstacleSpeed = 1;

  function animate() {
    framecounter += 1;
    if (framecounter > 150) {
      // roughly every five seconds with 30 FPS

      // update score
      let currentScore = parseInt(document.getElementById('scoreboard').innerHTML);
      document.getElementById('scoreboard').innerHTML = currentScore + Math.floor(10*obstacleSpeed);

      //
      // Bonus Part 2!
      //
      obstacleSpeed += 0.05;


      framecounter = 0;
    }

    gl.clearColor( 0.0, 0.0, 0.0, 0.0);
    gl.clear( gl.COLOR_BUFFER_BIT );

    for ( let o = 0; o < objects.length; o++ ) {
      let current_objecttype  = objects[o][0];
      let current_v_buffer    = objects[o][1];
      let current_i_buffer    = objects[o][2];
      let current_vertices    = objects[o][3];
      let current_offset      = objects[o][4];
      let current_color       = objects[o][5];
      let current_drawtype    = objects[o][6];
      let current_i_count     = objects[o][7] ? objects[o][7].length : null;

      let current_v_count = current_vertices.length;

      if (current_objecttype === 'airplane') {
        // Check x and y offset. If airplane bumped edge of screen, nudge towards middle.
        if (Math.abs(current_offset[0]) >= 1.0) current_offset[0] = Math.sign(current_offset[0]) * 0.95;
        if (Math.abs(current_offset[1]) >= 1.0) current_offset[1] = Math.sign(current_offset[1]) * 0.95;

        // Update airplane offset
        current_offset[0] += direction_x * step_x;
        current_offset[1] += direction_y * step_y;

      } else if (current_objecttype === 'obstacle') {
        //
        // Bonus Part 1!
        //
        if (current_offset[0] <= -1.0) {
          current_offset[0] = 1.0;
          current_offset[1] = Math.random()*2 - 1.0;
          current_color[0] = Math.random();
          current_color[1] = Math.random();
          current_color[2] = Math.random();
        } else {
          current_offset[0] -= obstacleSpeed * 0.001;
        }


        let bbox_plane = calculateBoundingBox( airplane[3], airplane[4]);

        if (detectCollision(bbox_plane, current_offset)) {
          console.log("game over");
          document.getElementById('scoreboard').innerHTML += ' AND...GAME OVER!'
          return;
        }
      }
      //************************************************************//
      //
      // CONNECT SHADER WITH GEOMETRY
      //

      gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );

      if (current_i_buffer) {
        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );
      }

      // find the attribute in the shader source
      let a_position = gl.getAttribLocation( shaderprogram, 'a_position' );
      let u_offset   = gl.getUniformLocation( shaderprogram, 'u_offset' );
      let u_color    = gl.getUniformLocation( shaderprogram, 'u_color' );

      gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );
      gl.enableVertexAttribArray ( a_position );
      // find the uniform in the shader source
      gl.uniform3fv( u_offset, current_offset);
      gl.uniform4fv( u_color, new Float32Array(current_color) );

      //************************************************************//
      //
      // DRAW!
      //

      //
      // Bonus Part 3!
      //
      if (current_i_buffer) {
        // INDEXED GEOMETRY
        gl.drawElements( gl.TRIANGLES, current_i_count, gl.UNSIGNED_BYTE, 0);
      } else {
        // Regular geometry
        gl.drawArrays( current_drawtype, 0, current_v_count/3, 0 );
      }
    }
    requestAnimationFrame(animate);
  }
</script>
<body>
<canvas id="c"></canvas>
<div id="scoreboard">0</div>
</body>
</html>